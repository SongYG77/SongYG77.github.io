{"pages":[],"posts":[{"title":"post","text":"","link":"/2020/07/10/post/"},{"title":"Hexo의 시작","text":"블로그 시작블로그를 만들겠다고 생각한 후 어떤 것을 이용하여 만들지 고민을 했었다.카카오, 네이버 등등 일반적으로 많이 알려진 블로그도 있었고 다른 사이트들도 많았었다. 처음에 notion을 사용하다 무언가 부족한 느낌이 들어 찾아본 것이 github.io였다.이것은 github를 이용해 자신만의 페이지를 만들 수 있었다. 물론 notion을 사용하면 글쓰기의 편리함이 있과 관리나 스타트가 굉장히 쉬웠다. 하지만 블로그 프레임 워크를 사용할 경우 마크다운을 이용해 글을 작성해야 하는 불편함 등이 있다.그래도 심화된 블로그 운영을 하고 싶어서 github io를 이용하게 되었다. github io를 만들 때 사용할 블로그 프레임 워크로 Jekyll과 Hexo가 있었는데,더 빠르고 로컬확인이 간편한 Hexo에 이끌려서 hexo를 이용하게 되었다. Hexo?Hexo는 블로그 프레임 워크로 Node.JS를 기반으로 한다. 포스트의 경우 마크다운 문서를 페이지로 변환하여 블로그의 포스트 형태로 바꾸어준다. 그래서 기본적으로 마크다운에 대해 거부감이 없는 사람이라면 이것을 이용해 개인블로그를 만드는 것을 추천한다. Hexo를 이용하여 무료 서버들에 손쉽게 접근하여 올릴수 있는데 그중 대표적으로 사용되는 github도 이용이 가능하다. Hexo를 사용하기 위해선 Node.JS와 git이 설치가 되어있어야 한다. Hexo : https://hexo.io Node.js : https://nodejs.org Git : https://git-scm.com Hexo 설치1234567**npm install -g hexo-cli****hexo init 이름****cd 이름****npm install** 위 명령어들을 작성한다. 이름의 경우는 자신이 원하는 이름을 적어주면 된다. 실행을 하면 ‘이름’폴더 아래에 여러가지 폴더가 생긴다. 이제 전체적인 스타트는 끝이 났다.만약 중간에 오류가 뜨면 보통은 그 아래 해결하기 위한 방법을 제시해 준다.그 방법을 따라해보면 좋다. Hexo 테마Hexo를 이용하여 만든 테마들이 많다. 워낙 유명하고 많은 사람들이 사용하기 때문에 공개되어 있는 테마들을 찾아 적용하면 된다. 공개된 테마들을 github에 찾아 들어가면 코드 링크가 있다. 그 링크를 복사한 후 themes 디렉토리로 이동해**git clone git링크**를 적어주면 자동으로 다운로드 한다. themes디렉토리에 보면 다운받은 테마의 디렉토리명이 있는데 그것을 “_config.yml” 파일의 theme 부분에 적어준다. 기본값으로 landscape라고 적혀 있는 부분을 바꿔주면 된다. Git 연결먼저 git을 연결해주는 플러그인을 설치해야 한다. **npm install hexo-deployer-git --save** 그리고 테마 적용할 때 사용했던 _config.yml을 들어가준다.아래 보면 deploy: 부분이 있는데 1234deploy:&lt;br&gt; type: git&lt;br&gt; repo: 자신의 git 레파지토리&lt;br&gt; branch: master&lt;br&gt; 으로 수정해 준다. 그러면 이제 hexo에서 배포를 할 때 자신의 git에 올라가게 된다.배포할 때 주로 사용되는 명령어로는 generate와 deploy가 있다. hexo generate** :정적 파일을 생성한다. github io는 정적 웹사이트 구축이므로 파일을 만들어 줘야 한다.1234````**$ hexo deploy** :만든 파일들을 배포한다. `&lt;br&gt;&lt;br&gt;처음 deploy 할 때 자신이 누구인지 알려달라는 문구가 나온다. 이는 git에 올라갈 때 어떤 이름과 이메일을 사용할 지 설정하는 것이다. &lt;br&gt; git config –global user.email “이메일”git config –global user.name “이름” 을 입력하고 다시 deploy 하면 해결된다. 그리고 올릴 github 레파지토리에 보면 설정하는 부분이 있다. page란에 가면 source에 branch master로 바꿔야 정상적으로 동작한다. 바꾸면 자신의 블로그 URL이 나오게 된다. &lt;br&gt;&lt;br&gt; ## 마침. 블로그를 만든지 초창기라 여러가지 공부를 하고 있다. hexo를 보면 여러가지 구현할 수 있는 것들이 많다(썸네일, 댓글 등등). 이런것들을 좀 더 많이 공부하여 완성도 높은 블로그를 만들때까지 노력할 것이다. &lt;br&gt;&lt;br&gt;","link":"/2020/07/10/Hexo%EC%97%90%EC%84%9C-%EC%9E%90%EC%A3%BC-%EC%82%AC%EC%9A%A9%EB%90%A0-%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9D%B8-%EB%AA%85%EB%A0%B9%EC%96%B4%EB%93%A4/"},{"title":"정렬 K번째 수","text":"링크프로그래머스 - 정렬 K번째 수 코드다음 문제는 간단하게 해결이 가능하다.commands의 수를 입력받아 얼만큼의 수를 뽑아낼 지 결정한다.그 이후 슬라이싱 한 결과를 저장할 임시 리스트를 만든 후 정렬시킨다.정렬시킨 리스트에서 우리가 뽑아야 하는 숫자를 찾아 answer 리스트에 추가 시킨다.그러면 원하는 결과가 나오게 된다. 1234567891011array = [1,5,2,6,3,7,4]commands = [[2,5,3], [4,4,1], [1,7,3]]answer = []templst = []for i in range(len(commands)) templst = array[commands[i][0]-1:commands[i][1]] templst = sorted(templst) ans = templst[commands[i][2]-1] answer.append(ans)print(answer) 위 코드는 파이썬 프로그램에서 확인을 위해 array와 commands에 예제값을 집어넣어 실행한 것이다.프로그래머스 링크에서 확인과 채첨을 하는 경우 123456789def solution(array, commands): answer = [] templst = [] for i in range(len(commands)) : templst = array[commands[i][0]-1:commands[i][1]] templst = sorted(templst) ans = templst[commands[i][2]-1] answer.append(ans) return answer 처음 풀어보는 문제는 난이도가 가장 쉬운 것이였다. 그래서 푸는데 큰 어려움이 없었다.","link":"/2020/07/21/Sort-Index-Of-K/"},{"title":"스텍&#x2F;큐 주식가격","text":"링크프로그래머스 - 스텍/큐 주식가격 풀이1234567891011121314from collections import dequedef solution(prices): answer = [] q = deque(prices) count = 0; while q: n = q.popleft() for i in q : count += 1 if n &gt; i : break answer.append(count) count=0 return answer 다음 풀이를 보면 collections의 deque를 사용했다. 가격 리스트를 큐로 지정해 하나씩 앞에서 빼낸다. 그 빼낸 수를 나머지 남은 자료들과 비교를 하여 비교하는 수가 더 작다면 반복을 멈춘다.그러면 각 항목들이 언제 떨어지는지 나오게 된다.","link":"/2020/07/21/Stack-Queue-Prices/"},{"title":"스텍&#x2F;큐 기능개발","text":"링크프로그래머스 - 정렬 K번째 수 풀이이번 문제도 스텍과 큐에 관련된 문제다. 여러 분야의 개발이 이루어지는데, 각 분야에서의 현재진행량 개발속도가 주어진다. 그리고 개발 상황이 100이 되면 개발을 완료하고 배포가 가능하다.다만 앞에 있는 기능들이 배포가 되어야 뒤의 기능들이 배포될 수 있다. 즉 여기서는 인덱스가 작은 것들이 개발이 완료되야 그보다 큰 인데스의 기능이 완료될 수 있다. 아래는 내가 작성한 코드이다. 12345678910111213141516from collections import dequedef solution(progresses, speeds): answer = [] d1= deque(progresses) d2 = deque(speeds) c=0 while d1: d1 = deque(map(lambda x,y : x+y,d1,d2)) while d1 and d1[0] &gt; 99: d1.popleft() d2.popleft() c+=1 if c &gt; 0 : answer.append(c) c=0 return answer 위의 코드를 보면 데크를 이용하여 작성했다. 문제에서 보면 리턴값은 배포가 이루어지는 개수를 원하고 있다. 그래서 반복문을 통해 기능개발이 남아 있으면 루프가 돌도록 설정했다. 그리고 매 루프에서 기능들의 개발을 진행시켰다. 뒤의 기능들은 앞 기능이 배포되기 전엔 배포가 이루어지지 않는다. 그래서 인덱스0을 가지는 경우만 생각하여 조건을 짰고, 하루에 여러개의 배포가 이루어질 수 있기 때문에 안에 반복문을 하나 더 작성했다. 이후에 조금더 효율적인 방법을 찾는다면 100에서 현재 진행상황을 뺀 다음 진행속도로 나눈 값을 올림한 자료들로 생각을 한다면 더욱 간결하게 풀리지 않을 까 생각이 든다.","link":"/2020/07/21/function-dev/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"codingtest","slug":"codingtest","link":"/tags/codingtest/"},{"name":"sort","slug":"sort","link":"/tags/sort/"},{"name":"programmers","slug":"programmers","link":"/tags/programmers/"},{"name":"stack&#x2F;queue","slug":"stack-queue","link":"/tags/stack-queue/"}],"categories":[{"name":"startup","slug":"startup","link":"/categories/startup/"},{"name":"Coding_Test","slug":"Coding-Test","link":"/categories/Coding-Test/"}]}